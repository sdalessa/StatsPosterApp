npm init, created index and gitignore, then done git init.
npm install apollo-server graphql mongoose
for each query, there is a corresponding resolver ,which processes some logic and gives a return for the query. Grouping Queries and mutations under respective objects. With sayHi and Hello World we have tested the query/response directly at local host 5001, because Graph QL provides an interface to do that directly there.
created a config file where I store the string/connection with user and psw securely, and this file is also listed in the gitignore file (best practice)
create database MODULES: new Schemas for Users and Posts (that are going to be on the socials!) created in the modules folder. By adding the 'users' to the schema we want to create a relation of the particular users by whom a particular post has been created (see that there is the value dot notation also points to an ObjectId). 
Creating a query for fetching all the posts from the db. We are gonna do that below with the getPosts, which will get all the posts from our db, will go to the collection posts, bring all docs from there and return them back to the user. 
Before step 6 though, we are going to create some data into the database. So we go into Atlas and go to the cluster, and then COLLECTIONS, and then create DB with own data. Created the first document there, and now I can fetch it.
Okay, written the fetching function as async in the index file. Exciting experience. Went to test if we are able to get the record that we created from the db through the UI in the localhost (that graphQL provides), and we are getting an empty array as a result. SOLUTION: we had to now specify inside the string that is used in the config.js file the NAME OF THE DATABASE as we defined it through Atlas. This part goes before the question mark! Very exciting!
After realizing that a mistake in the syntax in the record I created in atlas was throwing an error when fetching, everything now seems to be working in GraphQL.
WANTED IMPROVEMENTS: typDefs and resolvers are in the index. We are going to move them from there. 
Before the CRUD operations for posts, we want to create ways for USERS TO AUTHENTICATE so that the auth users only can do CRUDs. This we can do by working on the typeDefs, with the type/obj Mutation (called like that because this is making changes to our database, we need to take input from our users as arguments for that). This type of object is connected to the input called RegisterInput, because eventually mutation wants to return a User, which is either newly registering, or is providing signin credentials. 
12. TODO IN THE NEXT NOTES: 
-- validate user data: make sure to have server validation in case pwd not matching, email does not exist etc. unique username, 
-- create auth token / new packages installed: npm install bcryptjs jsonwebtoken. in users.js we destructure registerInput
13. TESTED AND WORKS! Just created a users collection in the atlas database! Basically (after having written all that code in users, for the users registration, and stored in the config.js the secret key) you compile the object inside of GraphQL UI and then you run it, it assigns to the user a unique token number! And then the users folder is created into mongo atlas. Exciting! We are registering users! Need to make sure the user name is unique too!
14. Implemented code to throw error in case username has already been taken/used
15. REQUIRED IMPROVEMENT: The system should not allow to register an empty user or similar condition. Creating the UTIL folder, with the validators.js file. Inside I create a function that takes as parameters all those required fields in the user definition (username, password and confirm pwd and email). In the function body, I create an error variable, that checks if email and pwd fields are empty, returning corresp errors. 
16. Completed work on validators.js, including a regEx to check the valid form of email addresses. Now in the testing environment, we see the respective error messages for empty user name, malformed email, or non matching psw.
17. implementing the login functionality now. Creating a validator for login data as well, with an empty errors object.